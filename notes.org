* 1.0 features
- editing functions
  - cut
  - paste
  - copy
  - mark select
  - cursor
- read/write files from disk
* todo
@spader 4/8/19: Fix the way you determine the padding between lines. Right now,
you just move the point down by however tall the tallest character is. But a few
characters dip below, so characters can intersect. 

@spader 4/8/19: The Shader_Info stuff is bad. I hate make_blah_shader_info. 
* write stuff here
- FOR TOMORROW: 
make the cursor work properly -- inside the context you have a screen position
and an index into the text buffer. 
fix that padding problem 
add marks 

- make all the configs in pure C -- dont even worry about using a config
  language
- cop the idea of modes: modes define a hook that runs when you enter it. this
  is what will set up your key bindings (not sure what other stuff)
- rope:
  - do i have to have individual allocations for each piece of the buffer that
    is stored at the leaf?
  - how do i find a specific character or substring?
- API ideas for the text buffer
  - get()
  - push()
  - pop_n()
- cursor needs to have screen position + buffer position
- custom editor functions all have the same signature (lets you use function
  pointers) and they accept a context to the editor state (which will be broken
  up into things that need to be in the public context and things that donut)
#+BEGIN_SRC c
typedef void (*)(EditorContext* ctx) EditorFunction;
#+END_SRC
* OOF
** opengl
*VBO*: Vertex Buffer Object. This is the handle to a chunk of GPU memory. 
*glVertexAttribPointer*: A call that modifies OpenGL state to tell it how to
interpret the vertex buffer it gets. This is the place where you tell OpenGL how
the data you are sending it is stored. 
*VAO*: Nothing but a wrapper around several calls to the above. It is annoying
to tell OpenGL how your data is stored in excruciating detail every time you
want to use your vertex buffer, so you use this to replay those calls. 
** why you have to enable textures
Default GL_TEXTURE_MIN_FILTER is GL_NEAREST_MIPMAP_LINEAR. Moreover, there is a
parameter of the texture called GL_TEXTURE_MAX_LEVEL which sets the index of the
highest defined mipmap level. If you don't specify it, it defaults to 1000. 

Now, imagine that you don't know about this parameter. You don't create mipmaps
(either because you are unaware of their function or you don't need them). Now
you're in an OpenGL state where:

1. The texture has a defined mipmap max level. OpenGL will therefore try to use
   mipmaps when appropriate
2. You have no mipmaps

You can see the problem. The solution to this is to either fix 1 (Tell OpenGL
that you have no mipmaps) or fix 2 (generate the mipmaps). 
** compiling on mac
- Frameworks to link against
  - Cocoa     (duh)
  - OpenGL    (duh)
  - CoreVideo (?)
  - IOKit     (?)
- You <have> to include this line in your source, before you initialize your
  GLFW window. Why? I'm not sure.
#+BEGIN_SRC c
glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#+END_SRC

